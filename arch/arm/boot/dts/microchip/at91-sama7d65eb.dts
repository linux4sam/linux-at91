// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 *  at91-sama7d65.dts - Device Tree file for SAMA7D65 board
 *
 *  Copyright (c) 2023 Microchip Technology Inc. and its subsidiaries
 *
 *
 */
/dts-v1/;
#include "sama7d65-pinfunc.h"
#include "sama7d65.dtsi"
#include <dt-bindings/mfd/atmel-flexcom.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/pinctrl/at91.h>
#include <dt-bindings/sound/microchip,pdmc.h>

/* Select LCD interface: have this macro defined for MIPI DSI or undefined for LVDS */
#define LCD_DSI_NOT_LVDS

/ {
	model = "Microchip SAMA7D65 DDR3 EB";
	compatible = "microchip,sama7d65-ddr3-eb", "microchip,sama7d65", "microchip,sama7";

	chosen {

		bootargs = "rw root=/dev/mmcblk0p2 rootfstype=ext4 rootwait";
		stdout-path = "serial0:115200n8";
	};

	aliases {
		serial0 = &uart4;
		i2c0 = &i2c0;
		i2c1 = &i2c5;
		i2c2 = &i2c3;
	};

	clocks {
		slow_xtal {
			clock-frequency = <32768>;
		};

		main_xtal {
			clock-frequency = <24000000>;
		};
	};

	display {
		/* LVDS WVGA Display panel Microchip AC69T88A */
		compatible = "sitronix,st7262", "simple-panel";
		power-supply = <&mic23150_reg>;
		backlight = <&backlight>;
		/* Warning: depending on board setup I3C or mikroBUS may own PC5 */
		reset-gpios = <&pioA PIN_PC5 GPIO_ACTIVE_LOW>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_lcd_reset>;
		width-mm = <108>;
		height-mm = <65>;
#ifdef LCD_DSI_NOT_LVDS
		status="disabled";
#else
		status="okay";
#endif

		port {
			lcd_lvds_in: endpoint {
				remote-endpoint = <&lvdsc_out>;
			};
		};
	};

	gpio-keys {
		compatible = "gpio-keys";

		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_key_gpio_default>;

		button {
				label = "PB_USER";
				gpios = <&pioA PIN_PA16 GPIO_ACTIVE_LOW>;
				linux,code = <KEY_0>;
				wakeup-source;
		};
	};

	leds {
		compatible = "gpio-leds";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_led_gpio_default>;
		status = "okay"; /* Conflict with pwm. */

		red_led {
			label = "red";
			gpios = <&pioA PIN_PA19 GPIO_ACTIVE_HIGH>;
		};

		green_led {
			label = "green";
			gpios = <&pioA PIN_PA20 GPIO_ACTIVE_HIGH>;
		};

		blue_led {
			label = "blue";
			gpios = <&pioA PIN_PA21 GPIO_ACTIVE_HIGH>;
			linux,default-trigger = "heartbeat";
		};
	};

	mic23150_reg: mic23150_regulator {
		compatible = "regulator-fixed";
		regulator-name = "panel-power-supply";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		gpios = <&pioA PIN_PD5 GPIO_ACTIVE_HIGH>;
		enable-active-high;
		status = "okay";
	};

	backlight: backlight {
		compatible = "pwm-backlight";
		pwms = <&xlcdc_pwm 0 1000000 0>;
		brightness-levels = <0 4 8 16 32 64 128 255>;
		default-brightness-level = <7>;
		power-supply = <&vdd_5v>;
		status = "okay";
	};

	memory@60000000 {
		device_type = "memory";
		reg = <0x60000000 0x10000000>;
	};

	vdd_5v: fixed-regulator-vdd-5v {
		compatible = "regulator-fixed";
		regulator-name = "VDD_5V";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
		status = "okay";
	};
};

&adc {
	vddana-supply = <&vddout25>;
	vref-supply = <&vddout25>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_adc_default>;
	status = "okay";
};

&can1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_can1_default>;
	status = "okay";
};

&can2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_can2_default>;
	status = "okay";
};

&cpu0 {
	cpu-supply = <&vddcpu>;
};

&dma0 {
	status = "okay";
};

&dma1 {
	status = "okay";
};

&dma2 {
	status = "okay";
};

&dsi {
#ifdef LCD_DSI_NOT_LVDS
	status = "okay";
#endif
	#address-cells = <1>;
	#size-cells = <0>;

	ports {
		#address-cells = <1>;
		#size-cells = <0>;

#ifdef LCD_DSI_NOT_LVDS
		port@0 {
			reg = <0>;
			dsi_in: endpoint {
				remote-endpoint = <&xlcdc_out>;
			};
		};
#endif

		port@1 {
			reg = <1>;
			dsi_out: endpoint {
				remote-endpoint = <&mipi_in_panel>;
			};
		};
	};

	panel@0 {
		reg = <0>;
		compatible = "hannstar,hsd060bhw4";
		backlight = <&backlight>;
		vcc-supply = <&mic23150_reg>;
		iovcc-supply = <&vldo1>;
		/* Provide the panel-himax-hx8394 driver with a fake GPIO.
		 * When targeting DSI, PD7 is open, not wired to the display. */
		reset-gpio =  <&pioA PIN_PD7 GPIO_ACTIVE_LOW>;
		status = "okay";
		#address-cells = <1>;
		#size-cells = <0>;

		port@0 {
			reg = <0>;
			mipi_in_panel: endpoint {
				remote-endpoint = <&dsi_out>;
			};
		};
	};
};

&flx0 {
	atmel,flexcom-mode = <ATMEL_FLEXCOM_MODE_TWI>;
	status = "okay";

	i2c0: i2c@600 {
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2c0_default>;
		i2c-analog-filter;
		i2c-digital-filter;
		i2c-digital-filter-width-ns = <35>;
		status = "okay";

		mxt: atmel_mxt_ts@4a {
			compatible = "atmel,maxtouch";
			reg = <0x4a>;
			interrupt-parent = <&pioA>;
			interrupts = <PIN_PD4 0x0>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_mxt_irq>;
			vdda-supply = <&mic23150_reg>;
			vdd-supply = <&vdd_3v3>;
			status = "okay";
		};
	};
};

&flx1 {
	atmel,flexcom-mode = <ATMEL_FLEXCOM_MODE_SPI>;
	status  = "okay";
};

&spi1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_mikrobus1_spi &pinctrl_mikrobus1_spi_cs>;
	status = "okay";
};

&flx3 {
	atmel,flexcom-mode = <ATMEL_FLEXCOM_MODE_TWI>;
	status = "okay";

	i2c3: i2c@600 {
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2c3_default>;
		i2c-analog-filter;
		i2c-digital-filter;
		i2c-digital-filter-width-ns = <35>;
		status = "okay";
	};
};

&flx4 {
	atmel,flexcom-mode = <ATMEL_FLEXCOM_MODE_USART>;
	status = "okay";

	uart4: serial@200 {
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_flx4_default>;
		status = "okay";
	};
};

&flx5 {
	atmel,flexcom-mode = <ATMEL_FLEXCOM_MODE_TWI>;
	status = "okay";

	i2c5: i2c@600 {
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_i2c5_default>;
		i2c-analog-filter;
		i2c-digital-filter;
		i2c-digital-filter-width-ns = <35>;
		status = "okay";

		mcp16502@5b {
			compatible = "microchip,mcp16502";
			reg = <0x5b>;
			status = "okay";

			regulators {
				vdd_3v3: VDD_IO {
					regulator-name = "VDD_IO";
					regulator-min-microvolt = <3300000>;
					regulator-max-microvolt = <3300000>;
					regulator-initial-mode = <2>;
					regulator-allowed-modes = <2>, <4>;
					regulator-always-on;

					regulator-state-standby {
						regulator-on-in-suspend;
						regulator-suspend-microvolt = <3300000>;
						regulator-mode = <4>;
					};

					regulator-state-mem {
						regulator-off-in-suspend;
						regulator-mode = <4>;
					};
				};

				vddioddr: VDD_DDR {
					regulator-name = "VDD_DDR";
					regulator-min-microvolt = <1350000>;
					regulator-max-microvolt = <1350000>;
					regulator-initial-mode = <2>;
					regulator-allowed-modes = <2>, <4>;
					regulator-always-on;

					regulator-state-standby {
						regulator-on-in-suspend;
						regulator-suspend-microvolt = <1350000>;
						regulator-mode = <4>;
					};

					regulator-state-mem {
						regulator-on-in-suspend;
						regulator-suspend-microvolt = <1350000>;
						regulator-mode = <4>;
					};
				};

				vddcore: VDD_CORE {
					regulator-name = "VDD_CORE";
					regulator-min-microvolt = <1150000>;
					regulator-max-microvolt = <1150000>;
					regulator-initial-mode = <2>;
					regulator-allowed-modes = <2>, <4>;
					regulator-always-on;

					regulator-state-standby {
						regulator-on-in-suspend;
						regulator-suspend-microvolt = <1150000>;
						regulator-mode = <4>;
					};

					regulator-state-mem {
						regulator-off-in-suspend;
						regulator-mode = <4>;
					};
				};

				vddcpu: VDD_OTHER {
					regulator-name = "VDD_OTHER";
					regulator-min-microvolt = <1050000>;
					regulator-max-microvolt = <1250000>;
					regulator-initial-mode = <2>;
					regulator-allowed-modes = <2>, <4>;
					regulator-ramp-delay = <3125>;
					regulator-always-on;

					regulator-state-standby {
						regulator-on-in-suspend;
						regulator-suspend-microvolt = <1050000>;
						regulator-mode = <4>;
					};

					regulator-state-mem {
						regulator-off-in-suspend;
						regulator-mode = <4>;
					};
				};

				vldo1: LDO1 {
					regulator-name = "LDO1";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					regulator-always-on;

					regulator-state-standby {
						regulator-suspend-microvolt = <1800000>;
						regulator-on-in-suspend;
					};

					regulator-state-mem {
						regulator-off-in-suspend;
					};
				};

				vldo2: LDO2 {
					regulator-name = "LDO2";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					regulator-always-on;

					regulator-state-standby {
						regulator-suspend-microvolt = <1800000>;
						regulator-on-in-suspend;
					};

					regulator-state-mem {
						regulator-off-in-suspend;
					};
				};
			};
		};

		eeprom0: eeprom@52 {
			compatible = "atmel,24c02"; /* EEPROM is 2Kbits microchip 24aa025e48, an at24c02 with page size of 16 */
			reg = <0x52>;
			pagesize = <16>;
			#address-cells = <1>;
			#size-cells = <0>;
			size = <256>;
			status = "okay";

			eeprom0_eui48: eui48@fa {
				reg = <0xfa 0x6>;
			};
		};

		eeprom1: eeprom@53 {
			compatible = "atmel,24c02"; /* EEPROM is 2Kbits microchip 24aa025e48, an at24c02 with page size of 16 */
			#address-cells = <1>;
			#size-cells = <0>;
			reg = <0x53>;
			pagesize = <16>;
			size = <256>;
			status = "okay";

			eeprom1_eui48: eui48@fa {
				reg = <0xfa 0x6>;
			};
		};
	};
};

&gmac0 {
	#address-cells = <1>;
	#size-cells = <0>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_gmac0_default
		     &pinctrl_gmac0_mdio_default
		     &pinctrl_gmac0_txck_default
		     &pinctrl_gmac0_phy_irq>;
	phy-mode = "rgmii-id";
	status = "okay";

	ethernet-phy@3 {
		reg = <0x3>;
		interrupt-parent = <&pioA>;
		interrupts = <PIN_PB7 IRQ_TYPE_LEVEL_LOW>;
		status = "okay";
	};
};

&gmac1 {
	#address-cells = <1>;
	#size-cells = <0>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_gmac1_default
		     &pinctrl_gmac1_mdio_default
		     &pinctrl_gmac1_txck_default
		     &pinctrl_gmac1_phy_irq>;
	phy-mode = "rgmii-id";
	status = "okay";

	ethernet-phy@3 {
		reg = <0x3>;
		interrupt-parent = <&pioA>;
		interrupts = <PIN_PE3 IRQ_TYPE_LEVEL_LOW>;
		status = "okay";
	};
};

&lvdsc {
#ifndef LCD_DSI_NOT_LVDS
	status = "okay";

	port@0 {
		reg = <0>;

		lvdsc_in: endpoint {
			remote-endpoint = <&xlcdc_out>;
		};
	};
#endif

	port@1 {
		reg = <1>;

		lvdsc_out: endpoint {
			remote-endpoint = <&lcd_lvds_in>;
		};
	};
};

&pioA {
	pinctrl_adc_default: adc_default {
		pinmux = <PIN_PC5__GPIO>;
		bias-disalbe;
	};

	pinctrl_can1_default: can1_default {
		pinmux = <PIN_PD10__CANTX1>,
			 <PIN_PD11__CANRX1>;
		bias-disable;
	};

	pinctrl_can2_default: can2_default {
		pinmux = <PIN_PD12__CANTX2>,
			 <PIN_PD13__CANRX2>;
		bias-disable;
	};

	pinctrl_gmac0_default: gmac0_default {
		pinmux = <PIN_PA26__G0_TX0>,
			 <PIN_PA27__G0_TX1>,
			 <PIN_PB4__G0_TX2>,
			 <PIN_PB5__G0_TX3>,
			 <PIN_PA29__G0_RX0>,
			 <PIN_PA30__G0_RX1>,
			 <PIN_PB2__G0_RX2>,
			 <PIN_PB6__G0_RX3>,
			 <PIN_PA25__G0_TXCTL>,
			 <PIN_PB3__G0_RXCK>,
			 <PIN_PA28__G0_RXCTL>;
		slew-rate = <0>;
		bias-disable;
	};

	pinctrl_gmac0_mdio_default: gmac0_mdio_default {
		pinmux = <PIN_PA31__G0_MDC>,
			 <PIN_PB0__G0_MDIO>;
		bias-disable;
	};

	pinctrl_gmac1_default: gmac1_default{
		pinmux = <PIN_PD22__G1_TX0>,
			 <PIN_PD23__G1_TX1>,
			 <PIN_PE0__G1_TX2>,
			 <PIN_PE1__G1_TX3>,
			 <PIN_PD27__G1_RX0>,
			 <PIN_PD28__G1_RX1>,
			 <PIN_PD30__G1_RX2>,
			 <PIN_PD31__G1_RX3>,
			 <PIN_PD21__G1_TXCTL>,
			 <PIN_PE2__G1_RXCK>,
			 <PIN_PD24__G1_RXCTL>;
		slew-rate = <0>;
		bias-disable;
	};

	pinctrl_gmac1_mdio_default: gmac1_mdio_default {
		pinmux = <PIN_PD25__G1_MDC>,
			 <PIN_PD26__G1_MDIO>;
		bias-disable;
	};

	pinctrl_led_gpio_default: led_gpio_default {
		pinmux = <PIN_PA19__GPIO>,
			 <PIN_PA20__GPIO>,
			 <PIN_PA21__GPIO>;
		bias-pull-up;
	};

	pinctrl_gmac0_txck_default: gmac0_txck_default {
		pinmux = <PIN_PB1__G0_REFCK>;
		slew-rate = <0>;
		bias-pull-up;
	};

	pinctrl_gmac1_txck_default: gmac1_txck_default {
		pinmux = <PIN_PD29__G1_REFCK>;
		slew-rate = <0>;
		bias-pull-up;
	};

	pinctrl_gmac1_phy_irq: gmac1_phy_irq {
		pinmux = <PIN_PE3__GPIO>;
		bias-pull-up;
	};

	pinctrl_i2c0_default: i2c0_default {
		pinmux = <PIN_PC7__FLEXCOM0_IO0>,
			<PIN_PC6__FLEXCOM0_IO1>;
		bias-pull-up;
	};

	pinctrl_i2c3_default: i2c3_default{
		pinmux = <PIN_PA24__FLEXCOM3_IO0>,
			 <PIN_PA23__FLEXCOM3_IO1>;
		bias-pull-up;
	};

	pinctrl_flx4_default: flx4_default {
		pinmux = <PIN_PA17__FLEXCOM4_IO1>,
			<PIN_PA18__FLEXCOM4_IO0>;
		bias-disable;
	};

	pinctrl_i2c5_default: i2c5_default{
		pinmux = <PIN_PD16__FLEXCOM5_IO0>,
			 <PIN_PD17__FLEXCOM5_IO1>;
		bias-disable;
	};

	pinctrl_gmac0_phy_irq: gmac0_phy_irq {
		pinmux = <PIN_PB7__GPIO>;
		bias-pull-up;
	};

	pinctrl_key_gpio_default: key-gpio-default {
		pinmux = <PIN_PA16__GPIO>;
		bias-disable;
	};

	pinctrl_lcd_disp_en: lcd-disp {
		pinmux = <PIN_PD7__LCDC_DISP>;
		bias-disable;
	};

	pinctrl_lcd_pwm: lcd-pwm {
		pinmux = <PIN_PD6__LCDC_PWM>;
		bias-disable;
	};

	pinctrl_lcd_reset: lcd-rst {
		pinmux = <PIN_PC5__GPIO>;
		bias-pull-up;
	};

	pinctrl_mikrobus1_spi_cs: mikrobus1_spi_cs {
		pinmux = <PIN_PC17__FLEXCOM1_IO3>;
		bias-disable;
	};

	pinctrl_mikrobus1_spi: mikrobus1_spi {
		pinmux = <PIN_PC14__FLEXCOM1_IO0>,
			 <PIN_PC15__FLEXCOM1_IO1>,
			 <PIN_PC16__FLEXCOM1_IO2>;
		bias-disable;
	};

	pinctrl_mxt_irq: pinctrl_mxt_irq {
		pinmux = <PIN_PD4__GPIO>;
		bias-pull-up;
		input-debounce = <1>;
	};

	pinctrl_sdmmc1_default: sdmmc1_default {
		cmd_data {
			pinmux = <PIN_PB22__SDMMC1_CMD>,
				 <PIN_PB24__SDMMC1_DAT0>,
				 <PIN_PB25__SDMMC1_DAT1>,
				 <PIN_PB26__SDMMC1_DAT2>,
				 <PIN_PB27__SDMMC1_DAT3>;
			slew-rate = <0>;
			bias-disable;
		};

		ck_cd_rstn_vddsel {
			pinmux = <PIN_PB23__SDMMC1_CK>,
				 <PIN_PB21__SDMMC1_RSTN>,
				 <PIN_PB30__SDMMC1_1V8SEL>,
				 <PIN_PB29__SDMMC1_CD>;
			slew-rate = <0>;
			bias-disable;
		};
	};

	pinctrl_sdmmc2_default: sdmmc2_default {
		cmd_data {
			pinmux = <PIN_PC27__SDMMC2_CMD>,
				 <PIN_PC29__SDMMC2_DAT0>,
				 <PIN_PC30__SDMMC2_DAT1>,
				 <PIN_PC31__SDMMC2_DAT2>,
				 <PIN_PD0__SDMMC2_DAT3>;
			slew-rate = <0>;
			bias-disable;
		};

		ck_cd_rstn_vddsel {
			pinmux = <PIN_PC28__SDMMC2_CK>,
				 <PIN_PD3__SDMMC2_1V8SEL>,
				 <PIN_PC10__GPIO>,
				 <PIN_PD2__SDMMC2_CD>,
				 <PIN_PD1__SDMMC2_WP>;
			slew-rate = <0>;
			bias-disable;
		};
	};

	pinctrl_usb_default: usb_default {
		pinmux = <PIN_PC11__GPIO>;
		bias-disable;
	};

	pinctrl_usbb_vbus_det: usbb_vbus_det {
		pinmux = <PIN_PC0__GPIO>;
		bias-disable;
	};

	pinctrl_usbb_vbus_en: usbb_vbus_en {
		pinmux = <PIN_PB31__GPIO>;
		bias-disable;
	};
};

&usb1 {
	atmel,vbus-gpio = <&pioA PIN_PC0 GPIO_ACTIVE_HIGH>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usbb_vbus_det>;
	status = "okay";
};

&ehci0 {
	status = "okay";
};

&ohci0 {
	num-ports = <3>;
	atmel,vbus-gpio = <0
			    &pioA PIN_PB31 GPIO_ACTIVE_LOW
			   &pioA PIN_PC11 GPIO_ACTIVE_LOW>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usb_default &pinctrl_usbb_vbus_en>;
	status = "okay";
};

&rtt {
	atmel,rtt-rtc-time-reg = <&gpbr 0x0>;
	status = "disabled";
};

&sdmmc1 {
	bus-width = <4>;
	vmmc-supply = <&vdd_3v3>;
	vqmmc-supply = <&vdd_3v3>;
	disable-wp;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_sdmmc1_default>;
	status = "okay";
};

&sdmmc2 {
	bus-width = <4>;
	vmmc-supply = <&vdd_3v3>;
	vqmmc-supply = <&vdd_3v3>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_sdmmc2_default>;
	status = "okay";
};

&shdwc {
	debounce-delay-us = <976>;
	microchip,lpm-connection = <&gmac1 &main_xtal>;
	status = "okay";

	input@0 {
		reg = <0>;
	};
};

&vddout25 {
	vin-supply = <&vdd_3v3>;
	status = "okay";
};

&xlcdc {
#ifdef LCD_DSI_NOT_LVDS
	clocks = <&pmc PMC_TYPE_PERIPHERAL 56>, <&pmc PMC_TYPE_GCK 56>, <&clk32k 1>;
	clock-names = "periph_clk", "sys_clk", "slow_clk";
	assigned-clocks = <&pmc PMC_TYPE_GCK 56>;
	assigned-clock-rates = <66000000>;
	assigned-clock-parents = <&pmc PMC_TYPE_CORE PMC_MCK1>;
#else
	clocks = <&pmc PMC_TYPE_PERIPHERAL 56>, <&pmc PMC_TYPE_CORE PMC_LVDSPLL>, <&clk32k 1>;
	clock-names = "periph_clk", "lvds_pll_clk", "slow_clk";
#endif
	status = "okay";

	hlcdc-display-controller {
#ifndef LCD_DSI_NOT_LVDS
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_lcd_disp_en>;
#endif

		port@0 {
			xlcdc_out: endpoint@0 {
				reg = <0>;
#ifdef LCD_DSI_NOT_LVDS
				remote-endpoint = <&dsi_in>;
#else
				remote-endpoint = <&lvdsc_in>;
#endif
			};
		};
	};

	xlcdc_pwm: hlcdc-pwm {
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_lcd_pwm>;
		status = "okay";
	};
};
